<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Diffusion Models | Matteo Lippi </title> <meta name="author" content="Matteo Lippi"> <meta name="description" content="an overview of the mathematics of Diffusion Models."> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%8E%B2&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://matteolippi.github.io/blog/2025/updatediff/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.min.css" integrity="sha256-q9ba7o845pMPFU+zcAll8rv+gC+fSovKsOoNQ6cynuQ=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github.min.css" integrity="sha256-Oppd74ucMR5a5Dq96FxjEzGF7tTw2fZ/6ksAqDCM8GY=" crossorigin="anonymous" media="screen and (prefers-color-scheme: light)"> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github-dark.min.css" integrity="sha256-nyCNAiECsdDHrr/s2OQsp5l9XeY2ZJ0rMepjCT2AkBk=" crossorigin="anonymous" media="screen and (prefers-color-scheme: dark)"> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/diff2html@3.4.47/bundles/css/diff2html.min.css" integrity="sha256-IMBK4VNZp0ivwefSn51bswdsrhk0HoMTLc2GqFHFBXg=" crossorigin="anonymous"> <link defer rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css"> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "Diffusion Models",
            "description": "an overview of the mathematics of Diffusion Models.",
            "published": "January 26, 2025",
            "authors": [
              
              {
                "author": "Matteo Lippi",
                "authorURL": "",
                "affiliations": [
                  {
                    "name": "",
                    "url": ""
                  }
                ]
              }
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Matteo</span> Lippi </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Notes </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Diffusion Models</h1> <p>an overview of the mathematics of Diffusion Models.</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div> <a href="#0-introduction-and-intuitions">0. Introduction and Intuitions</a> </div> <div> <a href="#1-defining-the-forward-process">1. Defining the Forward Process</a> </div> <div> <a href="#2-defining-the-reverse-process">2. Defining the Reverse Process</a> </div> <ul> <li> <a href="#note-variational-approach-and-equivalence-with-score-matching">Note: Variational approach and equivalence with Score Matching</a> </li> </ul> <div> <a href="#3-score-matching">3. Score Matching</a> </div> <ul> <li> <a href="#denoising-score-matching">Denoising Score Matching</a> </li> <li> <a href="#implicit-score-matching">Implicit Score Matching</a> </li> </ul> <div> <a href="#4-score-based-models">4. Score Based Models</a> </div> <div> <a href="#5-continuous-time-view">5. Continuous Time View</a> </div> <div> <a href="#6-equivalence-to-ordinary-differential-equation-ode-formulation">6. Equivalence to Ordinary Differential Equation (ODE) formulation</a> </div> <div> <a href="#7-conditional-generation-and-inverse-problems">7. Conditional Generation and Inverse Problems</a> </div> <div> <a href="#8-sources">8. Sources</a> </div> </nav> </d-contents> <h2 id="0-introduction-and-intuitions">0. Introduction and Intuitions</h2> <p>One of the main goals of generative modelling is, given samples \(x_i \sim p_{data}(x)\) from an unknown data distribution, to generate new samples \(x_{new}\). This is usually a complicated task, because:</p> <ol> <li>\(p_{data}(x)\) is not known.</li> <li>\(p_{data}(x)\) may have a very complicated form that makes sampling from it difficult.</li> </ol> <p>Diffusion models approach this problem by first sampling \(z_{new} \sim p_{easy}(x)\) from an easy-to-sample distribution, and then defining a way to transform \(z_{new}\) into a sample \(x_{new}\) of \(p_{data}(x)\). This is similar to what is done in other generative models, such as Variational Autoencoders or Normalising Flows.<br> A key insight of Diffusion Models is that transforming a sample between two probability distributions is easy if the transition is small. Because of this reason, to transform as sample from \(p_{easy}(x)\) into a sample from a potentially very different \(p_{data}(x)\), it is very useful to employ multiple transition steps. Essentially, being able to define an interpolation between two probability distributions is very useful for sampling.<br> It turns out that the connection between \(p_{data}(x)\) and \(p_{easy}(x)\) can be very naturally defined in terms of noising. If that is the case, going from \(z_{new}\) to \(x_{new}\) is intimately linked with a certain untractable quantity, the <strong>Stein Score</strong> of the data distribution. Approximating it is where Deep Learning and neural networks come into play.</p> <p>Historically, the idea of a Diffusion Model was reached from different perspectives, which sometimes makes the literature hard to navigate.</p> <ul> <li> <em>Sohl-Dickstein et al.</em> <d-cite key="og_diff"></d-cite> is the first paper on the topic, which used a Variational Inference approach.</li> <li> <em>Song and Ermon</em> <d-cite key="og_song"></d-cite> introduced the connection with Denoising Score Matching, seeing a Diffusion Model through the lenses of Score Based Models.</li> <li> <em>Ho et al.</em> <d-cite key="Ho"></d-cite> tied together the first two views.</li> <li> <em>Song et al.</em> <d-cite key="sde"></d-cite> generalised the existing Diffusion Model framework to continuous time processes.</li> </ul> <h2 id="1-defining-the-forward-process">1. Defining the Forward Process</h2> <p>We define \(p(\mathbf{x}_0,\mathbf{x}_1, ... ,\mathbf{x}_T)\) as a joint probability distribution over \((\mathbb{R}^d)^T\) , where the marginal \(p(\mathbf{x}_0)\) identifies the unknown data distribution and the marginal \(p(\mathbf{x}_T)\) identifies the easy-to-sample terminal distribution (usually Gaussian). As any joint probability distribution, we can express it using a Markov model factorisation. By applying the product rule, starting from \(p(\mathbf{x}_0)\) we obtain the following <strong>forward representation</strong>: \(\begin{equation} p(\mathbf{x}_0, \mathbf{x}_1, ..., \mathbf{x}_T) = p(\mathbf{x}_0) \prod_{t=1}^{T} p(\mathbf{x}_t \mid \mathbf{x}_{t-1}) \end{equation}\) This factorisation can be visualised using a Probabilistic Graphical Model as follows:</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/diff_fwd-480.webp 480w,/assets/img/diff_fwd-800.webp 800w,/assets/img/diff_fwd-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/diff_fwd.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Graphical model for the forward diffusion process. Adapted from <d-cite key="diff_pgm"></d-cite>. </div> <p>How do we choose the transition kernel \(p(\mathbf{x}_i \mid \mathbf{x}_{i-1})\) ? As we are looking for an easy to sample end distribution \(p(\mathbf{x}_T)\), a reasonable choice could be: \(\begin{equation} p(\mathbf{x}_t \mid \mathbf{x}_{t-1}) = \mathcal{N}(\mathbf{x}_t ; \sqrt{1 -\beta_t} \mathbf{x}_{t-1}, \beta_t \mathbf{I}) \label{forward} \end{equation}\)</p> <p>where \(\beta_t\) is a given noise schedule. This parametrisation ensures that \(p(\mathbf{x}_t)\) becomes approximately \(\mathcal{N}(\mathbf{0}, \mathbf{I})\). Will see later that convergence to a Gaussian is a characteristic feature of all process of this type (Ornstein–Uhlenbeck process, see more in Section 5).</p> <p>From a sampling perspective, this is equivalent to defining the following forward Markov Chain:</p> \[\begin{equation} \mathbf{x}_t = \sqrt{1 -\beta_t} \mathbf{x}_{t-1} + \sqrt{\beta_t} \mathbf{z}_{t-1} \quad \quad \mathbf{z}_{t} \sim \mathcal{N}(\mathbf{0}, \mathbf{1}), \quad \forall t \end{equation}\] <p>Having the transition kernel designed as such, we have access to a close form expression of \(p(\mathbf{x}_t \mid \mathbf{x}_{0})\) from which we can easily sample (see below). As will be clear later, this is a crucial property of the model. Allowing immediate access to a noised sample \(\mathbf{x}_t\) for any \(\mathbf{x}_0\) means that we do not have to go through the entire Markov Chain, guaranteeing large computational savings.<br> To see how this is true, first define:</p> \[\begin{equation*} \alpha_t = 1 - \beta_t, \quad \bar{\alpha}_t = \prod_{i=1}^t \alpha_i \end{equation*}\] <p>then observe that:</p> \[\begin{align*} \mathbf{x}_t &amp;= \sqrt{1 -\beta_t} \mathbf{x}_{t-1} + \sqrt{\beta_t} \mathbf{z}_{t-1} \\ &amp;= \sqrt{\alpha_t} \mathbf{x}_{t-1} + \sqrt{1 - \alpha_t} \mathbf{z}_{t-1} \\ &amp;= \sqrt{\alpha_t \alpha_{t-1}} \mathbf{x}_{t-2} + \sqrt{\alpha_t (1 - \alpha_{t-1})} \mathbf{z}_{t-2} + \sqrt{1 - \alpha_t} \mathbf{z}_{t-1} \\ &amp;= \sqrt{\alpha_t \alpha_{t-1}} \mathbf{x}_{t-2} + \sqrt{1 - \alpha_t \alpha_{t-1}} \tilde{\mathbf{z}}_{t-2} \\ &amp;= \sqrt{\bar{\alpha}_t} \mathbf{x}_{0} + \sqrt{1 - \bar{\alpha}_t} \tilde{\mathbf{z}}_{0} \end{align*}\] <p>where we used the identity that the sum of two Gaussian random variables \(\mathbf{z}_{1} \sim \mathcal{N}(\mathbf{0}, \sigma_1^2 \mathbf{I})\) and \(\mathbf{z}_{2} \sim \mathcal{N}(\mathbf{0}, \sigma_2^2 \mathbf{I})\) gives \(\tilde{\mathbf{z}} \sim \mathcal{N}(\mathbf{0}, \sigma_1^2 + \sigma_2^2 \mathbf{1})\).</p> <h2 id="2-defining-the-reverse-process">2. Defining the Reverse Process</h2> <p>Equivalently to the forward representation, we can also factorise \(p(\mathbf{x}_0, \mathbf{x}_1, ..., \mathbf{x}_T)\) starting from the end \(\mathbf{x}_T\) of the forward Markov Chain and proceeding in the <strong>reverse</strong> direction. \(\begin{equation} p(\mathbf{x}_0, \mathbf{x}_1, ..., \mathbf{x}_T) = p(\mathbf{x}_T) \prod_{t=T}^{1} p(\mathbf{x}_{t-1} \mid \mathbf{x}_t) \end{equation}\)</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/diff_rev-480.webp 480w,/assets/img/diff_rev-800.webp 800w,/assets/img/diff_rev-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/diff_rev.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Graphical model for the reverse diffusion process. Adapted from <d-cite key="diff_pgm"></d-cite>. </div> <p>The main question that a diffusion model tries to answer is: given a forward representation like the one in \(\eqref{forward}\) what is the reverse transition kernel \(p(\mathbf{x}_{t-1} \mid \mathbf{x}_t)\) ? Intuitively, this is a hard problem. As we are adding noise in the forward transitions \(p(\mathbf{x}_t \mid \mathbf{x}_{t-1})\), exact knowledge of the reverse \(p(\mathbf{x}_{t-1} \mid \mathbf{x}_t)\) implies being able to perfectly denoise a sample.<br> At the same time, even approximate knowledge of \(p(\mathbf{x}_{t-1} \mid \mathbf{x}_t)\) would enable us to generate a sample from any arbitrary data distribution \(p(\mathbf{x}_{0})\) by first starting from the easy to sample \(p(\mathbf{x}_T)\), and then “hopping” backwards on the reverse Markov Chain until \(p(\mathbf{x}_{0})\) is reached, in a process known as <strong>Ancestral Sampling</strong> in the Probabilistic Graphical Models literature.</p> <p>To find an approximation for the reverse transition probability, we first express it as a function of the forward kernel using Bayes’ Theorem: \(\begin{equation} p(\mathbf{x}_{t-1}|\mathbf{x}_t) = \frac{p(\mathbf{x}_{t-1}) p(\mathbf{x}_t \mid \mathbf{x}_{t-1})}{p(\mathbf{x}_t)} \label{bayes} \end{equation}\)</p> <p>while \(p(\mathbf{x}_t \mid \mathbf{x}_{t-1})\) is known, this formula suffers from the stereoptypical problem of Bayesian inference: \(p(\mathbf{x}_t)\) and \(p(\mathbf{x}_{t-1})\) are intractable, as they would require marginalisation over the rest of the other variables.<br> Without getting discouraged, in the following we will try to build an intuition for what type of terms to expect in \(p(\mathbf{x}_{t-1}|\mathbf{x}_t)\).<br> We plug in the functional form of \(p(\mathbf{x}_t \mid \mathbf{x}_{t-1})\) and rearrange as follows:</p> \[\begin{align*} p(\mathbf{x}_{t-1}|\mathbf{x}_t) &amp;= \frac{1}{Z} \exp\left(-\frac{\|\mathbf{x}_t - \sqrt{1 - \beta_t} \, \mathbf{x}_{t-1}\|^2}{2 \beta_t}\right) \frac{p(\mathbf{x}_{t-1})}{p(\mathbf{x}_t)} \\ &amp;= \frac{1}{Z} \exp\left(-\frac{\|\mathbf{x}_t - \sqrt{1 - \beta_t} \, \mathbf{x}_{t-1}\|^2}{2 \beta_t}\right) \exp \left(\log p(\mathbf{x}_{t-1}) - \log p(\mathbf{x}_t) \right) \end{align*}\] <p>In the limit of many noising steps \(T &gt;&gt; 1\), both the steps difference \(\|\mathbf{x}_t - \mathbf{x}_{t-1}\|^2\) and the noise variance \(\beta_t\) are small. This allows to Taylor expand the difference in the second exponential as follows:</p> \[\exp \left(\log p(\mathbf{x}_{t-1}) - \log p(\mathbf{x}_t) \right) = \exp \left( \nabla_{\mathbf{x}_t} \log p(\mathbf{x}_t) \cdot (\mathbf{x}_{t-1} - \mathbf{x}_t) + \mathcal{O}(\beta_t^2) \right)\] <p>Plugging this back in the expression for \(p(\mathbf{x}_{t-1} \mid \mathbf{x}_t)\) yields:</p> \[\begin{align*} p(\mathbf{x}_{t-1}|\mathbf{x}_t) &amp;= \frac{1}{Z} \exp\left(-\frac{\|\mathbf{x}_t - \sqrt{1 - \beta_t} \, \mathbf{x}_{t-1}\|^2}{2 \beta_t}\right) \exp \left(\nabla_{\mathbf{x}_t} \log p(\mathbf{x}_t) \cdot (\mathbf{x}_{t-1} - \mathbf{x}_t) + \mathcal{O}(\beta_t^2) \right) \\ &amp;= \frac{1}{Z} \exp\left(-\frac{\|\mathbf{x}_t - \sqrt{1 - \beta_t} \, \mathbf{x}_{t-1}\|^2 + 2\beta_t \nabla_{\mathbf{x}_t} \log p(\mathbf{x}_t) \cdot (\mathbf{x}_{t-1} - \mathbf{x}_t) + \mathcal{O}(\beta_t^3)}{2 \beta_t}\right) \end{align*}\] <p>At the numerator we can recognise a quadratic form of \(\mathbf{x}_{t-1}\), meaning that the whole expression can be approximated as a Gaussian!<br> More specifically, we can further manipulate the above expression (assuming that \(\| \log p(\mathbf{x}_{t-1}) - \log p(\mathbf{x}_t) \| = \mathcal{O}(\beta_t^2)\), completing the square and rearranging) to obtain:</p> \[\begin{equation} p(\mathbf{x}_{t-1}|\mathbf{x}_t) \approx \mathcal{N}(\mathbf{x}_{t-1}; \sqrt{1 + \beta_t} \, \mathbf{x}_{t} + \beta_t \nabla_{\mathbf{x}_t}\log p(\mathbf{x}_t), \beta_t \mathbf{I}) \label{reverse} \end{equation}\] <p>This is an exciting result, as it means that by sampling from the above Gaussian one can effectively reverse the Markov Chain defined in \(\eqref{forward}\).<br> The only problematic term that makes this sampling not trivial is the unknown \(\nabla_{\mathbf{x}_t}\log p(\mathbf{x}_t)\) appearing in the mean of the Gaussian. \(\nabla_{\mathbf{x}_t}\log p(\mathbf{x}_t)\) is known as <strong>Stein Score</strong> in the literature, and intuitively represents the vector field pointing in the direction of highest increase of the log likelihood in sample space \(\mathbb{R}^d\) (if i am at \(\mathbf{x}_t\), where should i go to get a more likely sample?).<br> But how can we find an estimator for the score of any given marginal \(p(\mathbf{x}_t)\)? To solve this problem we need to apply some techniques from the field of Score Matching.</p> <h3 id="note-variational-approach-and-equivalence-with-score-matching">Note: Variational approach and equivalence with Score Matching</h3> <p>Using the same starting point as the above derivation (Equation \(\eqref{bayes}\)), we could have also proceeded with a variational approach <d-cite key="og_diff"></d-cite>. Specifically, knowing that \(p(\mathbf{x}_{t-1} \mid \mathbf{x}_t)\) is approximately Gaussian, we could simply parametrise it using a neural network:</p> \[N(x_{t-1} \mid \mu_{\theta}(x_t, t), \Sigma_{\theta}(x_t, t))\] <p>and train the network by maximising an Evidence Lower Bound (ELBO), which is effectively a lower bound on the untractable log likelihood \(\log p(\mathbf{x}_{t-1})\).<br> We can view this setup as learning the “decoder” part of a Variational Autoencoder (VAE), where \(\mathbf{x}_t\) takes the role of the latent variable \(\mathbf{z}\). The only difference being that in this case the “encoder” model \(p(\mathbf{x}_{t}|\mathbf{x}_{t-1})\) is not learnable, as it is just adding noise. Generalising this intuition to the entire Markov Chain, we can define a Hierarchical VAE which has observable variable \(\mathbf{x}_0\) and latent variables \(\mathbf{z}_1, \mathbf{z}_2, ..., \mathbf{z}_T = \mathbf{x}_1, \mathbf{x}_2, ..., \mathbf{x}_T\), and proceed to optimise the ELBO.<br> The advantage of this formulation is that, instead of learning an approximation of the score \(\nabla_{\mathbf{x}_t}\log p(\mathbf{x}_t)\), we are learning a lower bound on the log likelihood, which can be very useful when comparing with other generative models (e.g. if our diffusion model has a higher ELBO then another model’s log likelihood, it means that our diffusion model must have higher log likelihood).</p> <p>A remarkable result by <d-cite key="Ho"></d-cite> shows that the loss function used by the variational approach is equivalent to Score Matching, specifically Denoising Score Matching, which will be presented below.</p> <h2 id="3-score-matching">3. Score Matching</h2> <p>We aim to use a function approximator \(\mathbf{s}_\theta(\mathbf{x}): \mathbb{R}^d \to \mathbb{R}^d\) , which in practice is represented by a Neural Network, to learn the score \(\nabla_\mathbf{x} \log p(\mathbf{x})\) of the data distribution \(p(\mathbf{x}_0)\) (or any given noisy marginal \(p(\mathbf{x}_t)\) of it). This is achieved by training \(\mathbf{s}_\theta(\mathbf{x})\) to minimise a Mean Squared Error loss given by:</p> \[\begin{equation}\mathbb{E}_{p(\mathbf{x})} \left[ \left\| \mathbf{s}_\theta(\mathbf{x}) - \nabla_{\mathbf{x}} \log p(\mathbf{x}) \right\|^2 \right] \label{ESM} \end{equation}\] <p>which is also referred to as Fisher Divergence or <strong>Explicit Score Matching</strong>.<br> In its standard form, \(\eqref{ESM}\) is not very useful because, although the term in brackets can be easily estimated via Monte Carlo, the first term cannot be accessed directly, since only samples are available from \(p(\mathbf{x})\).<br> To make this loss function tractable, two approaches can be considered:</p> <h3 id="denoising-score-matching">Denoising Score Matching</h3> <p>Denoising Score Matching (DSM) <d-cite key="vincent11"></d-cite> works by defining the Explicit Score Matching objective for \(q(\tilde{\mathbf{x}})\), a noisy version of \(p(\mathbf{x})\) obtained by applying a noising kernel \(q(\tilde{\mathbf{x}} \mid \mathbf{x})\) through a convolution:</p> \[q(\tilde{\mathbf{x}}) = \int q(\tilde{\mathbf{x}} \mid \mathbf{x}) p(\mathbf{x}) \, d\mathbf{x}\] <p>In our specific case, the noisy distribution \(q(\tilde{\mathbf{x}}) = p(\mathbf{x}_t)\), which is exactly what we are interested in. At the same time, this framework can (and was intended to) be applied more generally to approximate the score \(\nabla_{\mathbf{x}} \log p(\mathbf{x})\) of any data distribution through a noisy estimate \(\nabla_{\tilde{\mathbf{x}}} \log q(\tilde{\mathbf{x}})\).</p> <p>Using clever algebraic manipulations that isolate the constant terms (no dependence on \(\theta\)) and the untractable ones, we obtain (for full derivation see Appendix of <d-cite key="vincent11"></d-cite>):</p> \[\begin{equation} \mathbb{E}_{q(\tilde{\mathbf{x}})} \left[ \left\| \mathbf{s}_\theta(\tilde{\mathbf{x}}) - \nabla_{\tilde{\mathbf{x}}} \log q(\tilde{\mathbf{x}}) \right\|^2 \right] = \mathbb{E}_{p(\mathbf{x}) q(\tilde{\mathbf{x}} | \mathbf{x})} \left[ \left\| \mathbf{s}_\theta(\tilde{\mathbf{x}}) - \nabla_{\tilde{\mathbf{x}}} \log q(\tilde{\mathbf{x}} | \mathbf{x}) \right\|^2 \right] + \textit{const} \label{DSM} \end{equation}\] <p>The same result can also be obtained using Tweedie’s formula (see for example <a href="https://alexxthiery.github.io/posts/reverse_and_tweedie/reverse_and_tweedie.html" rel="external nofollow noopener" target="_blank">this blog post</a>).</p> <p>To see a clear connection with denoising, notice how, in the case of a Gaussian noise kernel \(\mathcal{N}(\tilde{\mathbf{x}} \mid \mathbf{x}, \sigma^2 \mathbf{I})\):</p> \[\nabla_{\tilde{\mathbf{x}}} \log q(\tilde{\mathbf{x}} | \mathbf{x}) = -\frac{(\tilde{\mathbf{x}} - \mathbf{x})}{\sigma^2}\] \[\tilde{\mathbf{x}} = \mathbf{x} + \sigma \mathbf{z} , \quad \mathbf{z} \sim \mathcal{N}(\mathbf{0}, \mathbf{I})\] <p>substituting both of the above in the right hand side of \(\eqref{DSM}\) yields the following loss function:</p> \[\begin{equation} \mathbb{E}_{p(\mathbf{x}) \mathbf{z} \sim \mathcal{N}(\mathbf{0}, \mathbf{I})} \left[ \left\| \mathbf{s}_\theta(\mathbf{x} + \sigma \mathbf{z}) + \frac{\mathbf{z}}{\sigma} \right\|^2 \right] \end{equation}\] <p>which clearly shows how the score approximator is effectively learning to predict the noise that was applied to its input.</p> <p>To gain further intuition on this connection between learning the score and denoising, one can also look at the Figure below, where a collection of samples \(\mathbf{x}_i \sim p(\mathbf{x})\) (empirical data density) is represented by Dirac deltas, and the noisy distribution \(q(\tilde{\mathbf{x}})\) is represented by the continuous line.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/denoising_deltas.PNG" sizes="95vw"></source> <img src="/assets/img/denoising_deltas.PNG" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> A collection of samples $\mathbf{x}_i \sim p(\mathbf{x})$ (empirical data density), and the noisy distribution $q(\tilde{\mathbf{x}})$ obtained from them. Adapted from <a href="https://deepgenerativemodels.github.io/syllabus.html" target="_blank" rel="external nofollow noopener">CS236</a> Lecture 13. </div> <p>the two following observations can be made with respect to the Figure:</p> <ul> <li>Learning the score \(\nabla_{\tilde{\mathbf{x}}} \log q(\tilde{\mathbf{x}})\) means learning a vector field that, if followed, brings to points \(\tilde{\mathbf{x}}_i\) where \(q(\tilde{\mathbf{x}})\) has a maximum.</li> <li>At the same time, \(q(\tilde{\mathbf{x}})\) is constructed by smoothing Diract deltas centered on the samples \(\mathbf{x}_i\) (noising process), and maximum points of \(q(\tilde{\mathbf{x}})\) correspond to known samples of \(p(\mathbf{x})\):</li> </ul> \[\tilde{\mathbf{x}}_i = \mathbf{x}_i\] <p>which implies that the two above mentioned tasks are essentially the same.</p> <h3 id="implicit-score-matching">Implicit Score Matching</h3> <p>An alternative approach is proposed in <d-cite key="hyv05"></d-cite>.<br> Expanding the square in \(\eqref{ESM}\) and realising the last term is constant (can not be optimised over) yields:</p> \[\begin{equation}\mathbb{E}_{p(\mathbf{x})} \left[ \left\| \mathbf{s}_\theta(\mathbf{x}) - \nabla_{\mathbf{x}} \log p(\mathbf{x}) \right\|^2 \right] = \mathbb{E}_{p(\mathbf{x})} \left[ \left\| \mathbf{s}_\theta(\mathbf{x}) \right\|^2 \right] + 2 \mathbb{E}_{p(\mathbf{x})} \left[ \mathbf{s}_\theta(\mathbf{x}) \cdot \nabla_{\mathbf{x}} \log p(\mathbf{x}) \right] + const \label{ism} \end{equation}\] <p>Considering the second term, we first apply the log trick \(\nabla p_t(\mathbf{x}) = \nabla \log p_t(\mathbf{x}) \cdot p_t(\mathbf{x})\), and then the multi dimensional integration by part formula (product rule of divergence), assuming that \(p(\mathbf{x}) \mathbf{s}_\theta(\mathbf{x}) \rightarrow 0\) at the border of its domain.</p> \[\begin{align*} \mathbb{E}_{p(\mathbf{x})} \left[ \mathbf{s}_\theta(\mathbf{x}) \cdot \nabla_{\mathbf{x}} \log p(\mathbf{x}) \right] &amp;= \int p(\mathbf{x}) \left[ \mathbf{s}_\theta(\mathbf{x}) \cdot \nabla_{\mathbf{x}} \log p(\mathbf{x}) \right] d \mathbf{x} \\ &amp;= \int \mathbf{s}_\theta(\mathbf{x}) \cdot \nabla_{\mathbf{x}} p(\mathbf{x}) d \mathbf{x} \\ &amp;= 0 + \int p(\mathbf{x}) \nabla_{\mathbf{x}} \cdot \mathbf{s}_\theta(\mathbf{x}) d \mathbf{x} \\ &amp;= \mathbb{E}_{p(\mathbf{x})} \big[\nabla_{\mathbf{x}} \cdot \mathbf{s}_\theta(\mathbf{x}) \big] \end{align*}\] <p>Plugging this back in Equation \(\eqref{ism}\), we are left with yet another tractable formulation of the Score Matching objective, known under the name of Implicit Score Matching (ISM).</p> \[\begin{equation}\mathbb{E}_{p(\mathbf{x})} \left[ \left\| \mathbf{s}_\theta(\mathbf{x}) - \nabla_{\mathbf{x}} \log p(\mathbf{x}) \right\|^2 \right] = \mathbb{E}_{p(\mathbf{x})} \left[ \left\| \mathbf{s}_\theta(\mathbf{x}) \right\|^2 \right] + 2 \mathbb{E}_{p(\mathbf{x})} \left[ \nabla_{\mathbf{x}} \cdot \mathbf{s}_\theta(\mathbf{x}) \right] + \textit{const} \end{equation}\] <p>A series of observations can be made:</p> <ul> <li>The main advantage of ISM over DSM is that it trains \(\mathbf{s}_\theta(\mathbf{x})\) to approximate the exact score, not the score \(\nabla_{\tilde{\mathbf{x}}} \log q(\tilde{\mathbf{x}})\) of a noisy version of the original data distribution. Even in the case where \(\nabla_{\tilde{\mathbf{x}}} \log q(\tilde{\mathbf{x}})\) was of interest, ISM doesnt not require any knowledge of the transition kernel \(q(\tilde{\mathbf{x}} \mid \mathbf{x})\).</li> <li>A major disadvantage of ISM is the computation of the score’s divergence \(\nabla_{\mathbf{x}} \cdot \mathbf{s}_\theta(\mathbf{x})\). This is what makes ISM not that convenient in the practical case of dealing with high dimensional data \(\mathbf{x} \in \mathbb{R}^d\) , where \(d&gt;&gt;1\). Specifically, computing \(\nabla_{\mathbf{x}} \cdot \mathbf{s}_\theta(\mathbf{x})\) with automatic differentiation would require \(d\) distinct backpropagations (one for each output dimension of the network \(\mathbf{s}_\theta(\mathbf{x})\)). To have a practical intuition for this, see the Figure below.</li> </ul> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/score_grad.PNG" sizes="95vw"></source> <img src="/assets/img/score_grad.PNG" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Computing the score's divergence requires $d$ backpropagations. Adapted from <a href="https://deepgenerativemodels.github.io/syllabus.html" target="_blank" rel="external nofollow noopener">CS236</a> Lecture 14. </div> <p>To alleviate such computational burden, <strong>Sliced Score Matching</strong><d-cite key="sliced_SM"></d-cite> applies some intuitions from randomised linear algebra in order to obtain a computationally lighter estimator:</p> \[\begin{equation} \mathbb{E}_{p_{\mathbf{v}},p(\mathbf{x})} \left[ \left\| \mathbf{v}^\intercal \mathbf{s}_\theta(\mathbf{x}) \right\|^2 + 2 \mathbf{v}^\intercal \nabla_{\mathbf{x}} \cdot \mathbf{s}_\theta(\mathbf{x}) \mathbf{v} \right] + \textit{const} \end{equation}\] <p>which can be practically viewed both as projecting both \(\mathbf{s}_\theta(\mathbf{x})\) and \(\nabla_{\mathbf{x}} \log p(\mathbf{x})\) onto a random direction \(\mathbf{v} \sim p_{\mathbf{v}}\) before computing ESM, or alternatively as applying Hutchinson’s trace estimation trick<d-cite key="sliced_SM"></d-cite> to \(\nabla_{\mathbf{x}} \cdot \mathbf{s}_\theta(\mathbf{x}) = tr[\mathbf{J}(\mathbf{s}_\theta(\mathbf{x}))]\).</p> <p>A final note is that all the above approaches rely on having a <strong>continuous</strong> probability density function for which the gradient (and consequently the score) exists.</p> <h2 id="4-score-based-models">4. Score Based Models</h2> <p>Before moving onto the continuous formulation of Diffusion Models, it is worth reviewing another equivalent formulation through the lenses of Score Based Modelling, which historically was the one uncovering the importance of Denoising Score Matching.</p> <p>Score based models are initially born from the observation that working with the score helps in solving some of the untractability problems of <a href="https://en.wikipedia.org/wiki/Energy-based_model" rel="external nofollow noopener" target="_blank">Energy Based Models</a> (see Chapter 24 of <d-cite key="pml2Book"></d-cite> for an excellent overview).<br> Specifically, given an Energy Based Model of the form:</p> \[\begin{equation} p(\mathbf{x}) = \frac{e^{-E(\mathbf{x})}}{Z}, \quad Z = \int e^{-E_(\mathbf{x})} d\mathbf{x} \end{equation}\] <p>working with the score allows to ignore the computationally intractable normalisation constant \(Z\):</p> \[\begin{align*} \nabla_{\mathbf{x}} \log p(\mathbf{x}) &amp;= -\nabla_{\mathbf{x}} E(\mathbf{x}) - \nabla_{\mathbf{x}} \log Z \\ &amp;= -\nabla_{\mathbf{x}} E(\mathbf{x}) - 0 \end{align*}\] <p>The key insight is that learning the score, $ \mathbf{s}_{\theta}(\mathbf{x})$, does not necessarily mean we are learning an Energy-Based Model (where the score is a conservative field). Instead, we are learning a more general generative model described by the score, which might not correspond to any energy function $E(\mathbf{x})$. This broader perspective defines the category of Score-Based Models.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/venn2.PNG" sizes="95vw"></source> <img src="/assets/img/venn2.PNG" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Score-based models in the landscape of generative models. Adapted from <a href="https://deepgenerativemodels.github.io/syllabus.html" target="_blank" rel="external nofollow noopener">CS236</a> Lecture 13. </div> <p>Once the score \(\nabla_\mathbf{x} \log p(\mathbf{x})\) is approximated (see Score Matching Chapter), generation can be achieved by the use of the <strong>Unadjusted Langevin Algorithm</strong>.<br> The Unadjusted Langevin Algorithm is a Markov Chain Monte Carlo (MCMC) sampling method that consists in running the following Markov Chain:</p> \[\begin{equation} \mathbf{x}_{i+1} = \mathbf{x}_i + \eta \nabla_\mathbf{x} \log p(\mathbf{x}_i) + \sqrt{2\eta} \boldsymbol{z}_i \quad \quad \mathbf{z}_{i} \sim \mathcal{N}(\mathbf{0}, \mathbf{1}) \end{equation}\] <p>where \(p(\mathbf{x}_i)\) is proven to converge to \(p(\mathbf{x})\) for \(i \rightarrow + \infty\) under reasonable assumptions.<br> To gain an intuition on what exactly the Unadjusted Langevin Algorithm is achieving, it can be helpful to view it as a noisy version of simple Gradient Ascent on \(p(\mathbf{x})\).</p> <p>When trying to implement the above sampling method, two problems become apparent:</p> <ol> <li>Langevin MCMC has a very slow mixing time. This can be intuitively understood by considering a mixture of Gaussians. If the noise term is not carefully tuned, the Markov Chain could be stuck on one of the two modes.</li> <li>The second and most relevant problem to Machine Learning applications is that the true \(p(\mathbf{x})\) is inaccessible and needs to be approximated from its samples \(\mathbf{x} \sim p(\mathbf{x})\) (the dataset). Especially considering the <a href="https://en.wikipedia.org/wiki/Manifold_hypothesis" rel="external nofollow noopener" target="_blank">Manifold Hypothesis</a>, a \(p(\mathbf{x})\) describing real world data often does not have support on the entire \(\mathbb{R}^d\) (some \(\mathbf{x}\) have zero probability, they are “impossible”). This property of \(p(\mathbf{x})\), coupled with the fact that a dataset may have scarce data regions, makes the estimation of \(\nabla_\mathbf{x} \log p(\mathbf{x})\) very inaccurate everywhere but in areas of \(\mathbb{R}^d\) that are particularly data dense (see top row of the Figure below). Clearly a wrong score estimation leads to incorrect sampling from the Langevin MCMC procedure.</li> </ol> <p>All of the above problems are addressed by learning the score of \(q(\tilde{\mathbf{x}})\), a noised version of \(p(\mathbf{x})\), which coincidentally can be obtained through Denoising Score Matching. Intuitively, this is understood by considering the noising process as a “smoothing” operator, which makes \(q(\tilde{\mathbf{x}})\) easier to work with.<br> More specifically, the samples now cover more uniformly \(\mathbb{R}^d\), and mixing between modes is accelerated as it is “easier” for the Markov Chain to switch between them.<br> The only problem becomes that we now have an accurate estimate of the score of \(q(\tilde{\mathbf{x}})\), which is not \(p(\mathbf{x})\). A trade-off can be identified where, the more noise is added, the easier a precise estimation becomes, but the further away from the real \(p(\mathbf{x})\) our estimation \(q(\tilde{\mathbf{x}})\) is.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/tradeoff_noising.PNG" sizes="95vw"></source> <img src="/assets/img/tradeoff_noising.PNG" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Illustrating the trade-off between estimation accuracy and data quality. Red encodes error. The bottom row is obtained by applying a noising kernel $q(\tilde{\mathbf{x}} \mid \mathbf{x})$ to the probability distribution of the top row. Adapted from <a href="https://deepgenerativemodels.github.io/syllabus.html" target="_blank" rel="external nofollow noopener">CS236</a> Lecture 14. </div> <p>The paper <d-cite key="og_song"></d-cite> had the brilliant intuition of leveraging this trade-off to define a sampling procedure called <strong>Annealed Langevin Algorithm</strong>.<br> The Annealed Langevin Algorithm starts by defining a family \(\{ q_i(\tilde{\mathbf{x}}) \}\) of noisy versions of \(p(\mathbf{x})\), each one obtained by applying a noising kernel \(q(\tilde{\mathbf{x}} \mid \mathbf{x}) = \mathcal{N}(\tilde{\mathbf{x}}; \, \mathbf{x}, \sigma_i \mathbf{I})\) with \(\sigma_i\) of different strength. Sampling from \(q_i(\tilde{\mathbf{x}})\) can be equivalently seen as starting from \(\mathbf{x_0} \sim p(\mathbf{x})\) and iteratively applying the following Markov Chain \(i\) times:</p> \[\begin{equation} \mathbf{x}_i = \mathbf{x}_{i-1} + \sqrt{\sigma_i - \sigma_{i-1}} \mathbf{z}_{i-1} \quad \quad \mathbf{z}_{i-1} \sim \mathcal{N}(\mathbf{0}, \mathbf{1}), \quad \sigma_0 = 0 \label{forward_song} \end{equation}\] <p>During training time, the scores \(\nabla_{\tilde{\mathbf{x}}} \log q_i(\tilde{\mathbf{x}})\) are estimated for all \(i\) using Denoising Score Matching. In practice, this is achieved by the use of a Noise Conditional Score Network, a score approximator \(\mathbf{s}_\theta(\mathbf{x}, \sigma_i)\) that also takes as an input the noise level \(\sigma_i\).<br> During the sampling phase, the original Langevin MCMC procedure is initially run for \(K\) steps using \(\mathbf{s}_\theta(\mathbf{x}, \sigma_{i_{MAX}})\), the score estimate of the \(q_i(\tilde{\mathbf{x}})\) with the most noise. The obtained samples are then used to initiate a new Langevin MCMC procedure with \(\mathbf{s}_\theta(\mathbf{x}, \sigma_{i_{MAX-1}})\), a slightly lower noise level. Iterating this process while slowly decreasing the amount of added noise \(\sigma_i\) all the way to \(\sigma_1\), yields samples from the wanted \(p(\mathbf{x})\).</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/adjusted_langevin.PNG" sizes="95vw"></source> <img src="/assets/img/adjusted_langevin.PNG" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Samples from three consecutive noise levels of the Annealed Langevin MCMC. Adapted from <a href="https://deepgenerativemodels.github.io/syllabus.html" target="_blank" rel="external nofollow noopener">CS236</a> Lecture 14. </div> <p>Running the Annealed Langevin Algorithm with \(K=1\):</p> \[\begin{equation} \tilde{\mathbf{x}}_{t} = \tilde{\mathbf{x}}_{t-1} + \eta \nabla_\tilde{\mathbf{x}} \log q_{t-1}(\tilde{\mathbf{x}}_{t-1}) + \sqrt{2\eta} \boldsymbol{z}_t \quad \quad \mathbf{z}_{t} \sim \mathcal{N}(\mathbf{0}, \mathbf{1}) \label{reverse_song} \end{equation}\] <p>is very similar to the process presented in Section 2, as they both rely on a Markov Chain having an expression that includes a score evaluation. To better understand the similarities between the two, we can leverage the unifying view of Continuous Time Diffusion Models.</p> <h2 id="5-continuous-time-view">5. Continuous Time View</h2> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/sde_fwd.PNG" sizes="95vw"></source> <img src="/assets/img/sde_fwd.PNG" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Continuous view of the forward diffusion process. Adapted from <a href="https://deepgenerativemodels.github.io/syllabus.html" target="_blank" rel="external nofollow noopener">CS236</a> Lecture 16. </div> <p>The main contribution of <d-cite key="sde"></d-cite> is the expansion of the discrete diffusion framework presented above to the continuous setting.</p> <p>As a high number of steps has proved to be helpful in going from \(p(\mathbf{x}_0)\) to \(p(\mathbf{x}_T)\), a natural question is if it could be possible to bring the step number to infinity.<br> This can be done by controlling the noising dynamics through a Stochastic Differential Equation (SDE), which can be written (using Ito notation) as:</p> \[\begin{equation} d \mathbf{x}_t = f(\mathbf{x}_t, t)dt + g(t)d\mathbf{w}_t \label{ito} \end{equation}\] <p>where \(\mathbf{w}_t\) represents a standard <a href="https://en.wikipedia.org/wiki/Wiener_process" rel="external nofollow noopener" target="_blank">Wiener Process</a>, also called Brownian Motion.</p> <p>Specifically, the Markov Chains defining the forward noising processes (both in Section 1 and 4) corresponds to the discretisation of two well-known SDEs: the Ornstein–Uhlenbeck SDE, and the Brownian Motion SDE. The discretisations can be obtained using a stochastic generalisation of the Euler method called <a href="https://en.wikipedia.org/wiki/Euler%E2%80%93Maruyama_method" rel="external nofollow noopener" target="_blank">Euler–Maruyama method</a>.</p> <ul> <li> <p>The Ornstein–Uhlenbeck (OU) SDE:</p> \[\begin{equation} d \mathbf{x}_t = - \frac{\beta(t)}{2} \mathbf{x}_tdt + \sqrt{\beta(t)} d\mathbf{w}_t \end{equation}\] <p>which, when discretised, yields Equation \(\eqref{forward}\) from Section 1 (where the square root term in \(\eqref{forward}\) is Taylor expanded). An important property of the OU SDE is that its solution converges exponentially fast to having \(\mathcal{Law}(\mathbf{x}_t) = \mathcal{N}(\mathbf{0}, c \mathbf{I})\) with fixed variance \(c\). Because of this reason it is also referred to as Variance Preserving (VP) SDE.</p> </li> <li> <p>The Brownian Motion SDE:</p> \[\begin{equation} d \mathbf{x}_t = \sqrt{\beta(t)} d\mathbf{w}_t \end{equation}\] <p>which, when discretised, yields Equation \(\eqref{forward_song}\) from Section 4. Its solution also has Gaussian law, but with the variance going to infinity. Because of this reason it is also referred to as Variance Exploding (VE) SDE.</p> </li> </ul> <p>To obtain samples we need to define a reverse process going from \(p(\mathbf{x}_T)\) to \(p(\mathbf{x}_0)\).<br> A remarkable result in SDE theory, which can be traced back to <d-cite key="anderson"></d-cite> <d-cite key="altrosde"></d-cite>, tells us that for any SDE of the form \(\eqref{ito}\), a <strong>Reverse SDE</strong> can be defined as:</p> \[\begin{equation} d \mathbf{x}_t = \big[ f(\mathbf{x}_t, t) - g(t)^2\nabla_{\mathbf{x}} \log p(\mathbf{x}_t) \big]dt+ g(t)d\tilde{\mathbf{w}_t} \end{equation}\] <p>where \(dt\) is a <strong>negative</strong> time increment, and \(\tilde{\mathbf{w}}_t\) is the time reversed Brownian Motion.<br> Intuition about the above reverse SDE can be gained by looking at the two drift contributions: \(f(\mathbf{x}_t, t)dt\) is the same drift found in the forward equation, but applied in the opposite direction, and \(\nabla_{\mathbf{x}} \log p(\mathbf{x}_t)dt\) is an additional drift term that reverses the diffusion process (concentrates the probability mass instead of spreading it).</p> <p>Applying this formula to the two SDEs defined above yields:</p> \[\begin{equation} d \mathbf{x}_t = \big[ - \frac{\beta(t)}{2} \mathbf{x}_t - \beta(t)\nabla_{\mathbf{x}} \log p(\mathbf{x}_t) \big]dt+ \sqrt{\beta(t)}d\tilde{\mathbf{w}_t} \end{equation}\] \[\begin{equation} d \mathbf{x}_t = \big[ -\beta(t) \nabla_{\mathbf{x}} \log p(\mathbf{x}_t) \big]dt+ \sqrt{\beta(t)}d\tilde{\mathbf{w}_t} \end{equation}\] <p>which bear a lot of similarities to Equations \(\eqref{reverse}\) and \(\eqref{reverse_song}\), justifying the SDE view of Diffusion Models as a natural generalisation of the previous results.</p> <p>The main advantages of a continuous framework are as follows:</p> <ul> <li>there is a lot of flexibility in the definition of the reverse process, intended as a solution of the reverse SDE. Specifically, parameters like discretisation step size and discretisation method can be tuned to have better control over the accuracy versus speed trade-off. An interesting approach to solving the reverse SDE is given by the Predictor-Corrector method.<br> The <strong>Predictor-Corrector method</strong> consists in leveraging information on the score to improve the accuracy of regular SDE solvers. It works by first performing a Predictor step, which approximates the value of \(\mathbf{x}_{T-\Delta t}\) using an SDE solver (e.g. Euler-Maruyama method). Subsequently, during the Corrector step, a Langevin MCMC procedure is run using score information \(\mathbf{s}_\theta(\mathbf{x}_{T- \Delta t}, T-\Delta t) \approx \nabla_{\mathbf{x}_{T- \Delta t}} \log p(\mathbf{x}_{T- \Delta t})\), improving the original sample \(\mathbf{x}_{T-\Delta t}\). Iterating these two steps allows to solve the reverse SDE achieving greater precision than a purely SDE solver approach, while also speeding up sampling compared to a purely Langevin MCMC approach like the one presented in Section 4.</li> </ul> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/predictor_corrector.PNG" sizes="95vw"></source> <img src="/assets/img/predictor_corrector.PNG" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Predictor-Corrector method. White arrows indicate the SDE solver, while red arrows indicate the Langevin MCMC correction. Adapted from <a href="https://deepgenerativemodels.github.io/syllabus.html" target="_blank" rel="external nofollow noopener">CS236</a> Lecture 16. </div> <ul> <li>As the reverse SDE result holds for <strong>any stochastic process</strong>, we effectively have access to a more general framework that can be applied to any noising process of choice. This being said, it is important to consider that, to have a model that is computationally feasible to train, a closed form of \(p(\mathbf{x}_t \mid \mathbf{x}_0)\) is essential to avoid simulating the entire forward process up to \(\mathbf{x}_t\) with Euler-Maruyama (or any other SDE solver)</li> <li>Choosing a OU SDE, we have theoretical guarantees that the process converges to a Gaussian distribution exponentially fast.</li> <li>As can be seen in the following Section, the continuous view allows for an ODE interpretation of the mapping between \(p(\mathbf{x_0})\) and \(p(\mathbf{x}_T)\), which has several advantages.</li> </ul> <h2 id="6-equivalence-to-ordinary-differential-equation-ode-formulation">6. Equivalence to Ordinary Differential Equation (ODE) formulation</h2> <p>Another remarkable contribution of <d-cite key="sde"></d-cite> is the observation that the forward/reverse SDEs can be reformulate in a deterministic way by describing the evolution of probability density.<br> This result can be achieved by writing the <a href="https://en.wikipedia.org/wiki/Fokker%E2%80%93Planck_equation" rel="external nofollow noopener" target="_blank">Fokker-Planck equation</a> (also known as Kolmogorov Forward Equation) associated with the forward/reverse SDE, and performing some simple algebraic manipulations to obtain another SDE without noise term (an ODE!), which takes the name of Probability Flow ODE in <d-cite key="sde"></d-cite>.<br> The crucial point of this derivation is that, as both equations satisfy the same Fokker-Planck Equation, their marginals \(p(\mathbf{x}_t)\) are the same.</p> <p>We start off by considering a given SDE</p> \[d \mathbf{x} = f(\mathbf{x}, t)dt + g(t)d \mathbf{w}\] <p>and writing its related Fokker-Planck equation:</p> \[\begin{align*} \frac{\partial p_t(\mathbf{x})}{\partial t} &amp;= -\nabla \cdot \big( f(\mathbf{x}, t) p_t(\mathbf{x}) \big) + \frac{1}{2} g(t)^2 \nabla^2 p_t(\mathbf{x}) \\ &amp;= - \nabla \cdot \big[ f(\mathbf{x}, t) p_t(\mathbf{x}) - \frac{1}{2} g(t)^2 \nabla p_t(\mathbf{x}) \big] \end{align*}\] <p>Using the log trick \(\nabla p_t(\mathbf{x}) = \nabla \log p_t(\mathbf{x}) \cdot p_t(\mathbf{x})\), substituting in the diffusion term and factoring \(p_t(\mathbf{x})\) out yields :</p> \[\begin{equation} \frac{\partial p_t(\mathbf{x})}{\partial t} = -\nabla \cdot \big( h(\mathbf{x}, t) p_t(\mathbf{x}) \big) \end{equation}\] <p>where \(h(\mathbf{x}, t) = f(\mathbf{x}, t) - \frac{1}{2} g(t)^2 \nabla \log p_t(\mathbf{x})\).</p> <p>This is an example of Liouville equation, a special case of the Fokker-Planck equation describing a process that is only driven by a deterministic term. Reverting from the Fokker-Planck to the SDE view of the process we get:</p> \[\begin{align} d \mathbf{x} &amp;= h(\mathbf{x}, t)dt \nonumber \\ &amp;= \big[ f(\mathbf{x}, t) - \frac{1}{2} g(t)^2 \nabla \log p_t(\mathbf{x}) \big]dt \\ \end{align}\] <p>For the more general case (SDEs with noise coefficients given by the matrix \(\mathbf{G}(\mathbf{x}, t)\)) please see <d-cite key="sde"></d-cite> Appendix A.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/ode_sde.PNG" sizes="95vw"></source> <img src="/assets/img/ode_sde.PNG" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> ODE and SDE formulations of a Diffusion Model. The two processes are different but have the same marginal distributions. Adapted from <a href="https://deepgenerativemodels.github.io/syllabus.html" target="_blank" rel="external nofollow noopener">CS236</a> Lecture 16. </div> <p>It is important to note that the SDE and ODE formulations describe two <strong>different</strong> processes. As both these processes solve the same Fokker-Planck equation, their marginal densities are the same, which is ultimately what we are interested in modelling.</p> <p>The ability to have an ODE formulation has several key advantages:</p> <ul> <li>The mapping between points \(\mathbf{x}_0\) and \(\mathbf{x}_T\) has now become fully deterministic, meaning that the above equations describe a Continuous Normalising Flow! <ul> <li>As likelihoods are tractable in Normalising Flows, we can have <strong>access to the model likelihoods</strong>. Even thought this is great, training through score matching is still preferred as likelihood computations are very slow compared to it (would need to solve the ODE on the full time length \(0\) to \(T\) for every datapoint)</li> </ul> </li> <li>Regular ODE solvers can be used to perform the sampling process. This is an advantageous property as existing literature on ODE solvers can be leveraged to control the trade-off between speed and accuracy</li> <li>Considering that the Forward ODE does not have any learnable parameters, and that there is an invertible deterministic mapping between \(p(\mathbf{x}_0)\) and \(p(\mathbf{x}_T)\), each data point \(\mathbf{x}_0\) has a latent encoding \(\mathbf{x}_T\) which is uniquely identifiable. This means that, as long as the dataset size, model capacity and optimisation accuracy are enough, the latent encoding depends only on \(p(\mathbf{x}_0)\), and is agnostic of model/optimiser/dataset choice. This is a remarkable property that is not shared by many other generative models (think about the fact that in a VAE the encoding is a learned process).</li> <li>Having a latent encoding also enables interpolation in latent space, similarly to other generative models.</li> </ul> <h2 id="7-conditional-generation-and-inverse-problems">7. Conditional Generation and Inverse Problems</h2> <p>So far we have looked at generating a sample from a probability distribution \(p(\mathbf{x})\), but in real world applications we are often interested in sampling from the conditional distribution \(p(\mathbf{x} \mid \mathbf{c})\). An example is <em>text-to-image</em> models, which generate an image \(\mathbf{x}\) given a text prompt \(\mathbf{c}\).</p> <p>This is particularly interesting as it formalises a wide range of inverse problems, which are commonly found in science and engineering, where the goal is to infer the underlying cause \(\mathbf{x}\) from some observed low dimensional (potentially noisy) data \(\mathbf{c}\).</p> <p>The easiest way to achieve a conditional diffusion model is to perform training on a labelled dataset of elements \((\mathbf{x}, \mathbf{c})\), and approximate the true conditional score \(\nabla_{\mathbf{x}} \log p(\mathbf{x|\mathbf{c}})\) with a learned score function of the form \(\mathbf{s}_\theta(\mathbf{x}, t, \mathbf{c})\), where the input \(\mathbf{c}\) is usually given by an embedding of the condition.<br> There are a couple of problems with this naive approach. The first one is that we need to retrain the entire model for different types of conditions \(\mathbf{c}_1\) and \(\mathbf{c}_2\), and we are not leveraging the shared structure of \(p(\mathbf{x})\).<br> The second and more subtle problem is that this approach does not allow for a way to trade off sample variance with sample quality, which is a feature that has great usefulness in many applications.</p> <p>To propose a solution to both problems, <d-cite key="class_guided"></d-cite> presents the idea of <strong>classifier guidance</strong>.<br> At its core, classifier guidance consists in observing that, by applying Bayes’ theorem to the conditional distribution \(p(\mathbf{x} \mid \mathbf{c}) = \frac{p(\mathbf{x}) p(\mathbf{c} \mid \mathbf{x})}{p(\mathbf{c})}\) and by taking the score \(\nabla_{\mathbf{x}} \log p(\mathbf{x} \mid \mathbf{c}) = \nabla_{\mathbf{x}} \log p(\mathbf{x}) + \nabla_{\mathbf{x}} \log p(\mathbf{c} \mid \mathbf{x}) - \nabla_{\mathbf{x}} \log p(\mathbf{c})\) the marginal \(p(\mathbf{c})\) gets canceled out.<br> This leaves us with:</p> \[\begin{equation} \nabla_{\mathbf{x}} \log p(\mathbf{x} \mid \mathbf{c}) = \nabla_{\mathbf{x}} \log p(\mathbf{x}) + \nabla_{\mathbf{x}} \log p(\mathbf{c} \mid \mathbf{x}) \end{equation}\] <p>The intuition in the above formula is that the second term “pushes” the sampling process towards areas of high probability \(p(\mathbf{c} \mid \mathbf{x})\), effectively introducing an additional drift term in the reverse SDE. Classifier guidance can be further enhanced into:</p> \[\begin{equation} \nabla_{\mathbf{x}} \log p_w(\mathbf{x} \mid \mathbf{c}) = \nabla_{\mathbf{x}} \log p(\mathbf{x}) + (w+1) \nabla_{\mathbf{x}} \log p(\mathbf{c} \mid \mathbf{x}) \label{clas_guid} \end{equation}\] <p>where \((w+1)\) is an additional factor which controls the strength of the guidance. By varying the value of \(w\), control over the above mentioned trade-off between sample variance and sample quality can be achieved.<br> A big advantage of this approach is that, given a pretrained classifier, the second term can be easily calculated by taking the gradient of its output \(\mathbf{c}\) with respect to the input \(\mathbf{x}\), avoiding the need to retrain the diffusion model from scratch. In practice, as we need the scores at any noise level \(t\), the classifier must also be trained on noisy versions of the dataset, meaning that a regular classifier would not work “out of the box”.<br> One of the drawbacks of classifier guidance lies in its high reliance on the classifier gradients, which are generally known to not exactly rely on all the core features of a given class. Similarly to an adversarial attack, the sampling process could prioritise directions that maximise \(p(\mathbf{c}|\mathbf{x})\) but do not correspond to very representative samples from the class \(\mathbf{c}\).<br> An alternative to classifier guidance that tackles some of these problems is given by <strong>classifier-free guidance</strong> <d-cite key="class_free"></d-cite>, whose core idea is to substitute the classifier’s guidance by the difference between two diffusion models, a conditional one and an unconditional one.<br> Starting from equation \(\eqref{clas_guid}\) and applying Bayes’ Theorem to the classifier term yields:</p> \[\begin{align} \nabla_{\mathbf{x}} \log p_w(\mathbf{x}|\mathbf{c}) &amp;= \nabla_{\mathbf{x}} \log p(\mathbf{x}) + (w+1) \big[ \nabla_{\mathbf{x}} \log p(\mathbf{x}|\mathbf{c}) - \nabla_{\mathbf{x}} \log p(\mathbf{x}) \big] \nonumber\\ &amp;= (w+1) \nabla_{\mathbf{x}} \log p(\mathbf{x}|\mathbf{c}) - w \nabla_{\mathbf{x}} \log p(\mathbf{x}) \end{align}\] <p>This alternative view of equation \(\eqref{clas_guid}\) shows that the additional weighting factor is equivalent to having a score that simultaneously pushes generation towards areas that have high \(p_w(\mathbf{x}|\mathbf{c})\), and away from areas that would otherwise be likely samples from \(p_w(\mathbf{x})\).<br> The same effect of classifier guidance can then be achieved by taking the difference between the conditional and unconditional models, which in practice are both obtained by training a single score function \(\mathbf{s}_\theta(\mathbf{x}, t, \mathbf{c})\), where sometimes the last input is left empty \(\mathbf{s}_\theta(\mathbf{x}, t, \emptyset)\).</p> <h2 id="9-sources">9. Sources</h2> <p>In addition to the cited papers, the sources that have greatly helped me navigate the literature are the following:</p> <ul> <li>“Introduction to Diffusion Models” <a href="https://www.youtube.com/watch?v=tNcDcF8J_1Y" rel="external nofollow noopener" target="_blank">lecture</a> and <a href="https://vdeborto.github.io/project/generative_modeling/" rel="external nofollow noopener" target="_blank">slides</a> by Valentin de Bortoli.</li> <li>“Diffusion Models” and “Energy Based Models” chapters in <a href="https://probml.github.io/pml-book/book2.html" rel="external nofollow noopener" target="_blank">Probabilistic Machine Learning: Advanced Topics</a> by Kevin Murphy.</li> <li>Two blog posts by <a href="https://yang-song.net/blog/2021/score/" rel="external nofollow noopener" target="_blank">Yang Song</a> and <a href="https://lilianweng.github.io/posts/2021-07-11-diffusion-models/" rel="external nofollow noopener" target="_blank">Lilian Weng</a>.</li> <li>Stanford CS236 <a href="https://www.youtube.com/playlist?list=PLoROMvodv4rPOWA-omMM6STXaWW4FvJT8" rel="external nofollow noopener" target="_blank">lectures</a> and <a href="https://deepgenerativemodels.github.io/syllabus.html" rel="external nofollow noopener" target="_blank">slides</a> by Stefano Ermon.</li> <li>“SDEs and Diffusion Models” <a href="https://sde-course.netlify.app/" rel="external nofollow noopener" target="_blank">course</a> by Kieran Didi and Francisco Vargas.</li> </ul> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/diffusion.bib"></d-bibliography> <div id="giscus_thread" style="max-width: 930px; margin: 0 auto;"> <script>
      let giscusTheme = determineComputedTheme();
      let giscusAttributes = {
        src: 'https://giscus.app/client.js',
        'data-repo': 'matteolippi/matteolippi.github.io',
        'data-repo-id': '',
        'data-category': 'Comments',
        'data-category-id': '',
        'data-mapping': 'title',
        'data-strict': '1',
        'data-reactions-enabled': '1',
        'data-emit-metadata': '0',
        'data-input-position': 'bottom',
        'data-theme': giscusTheme,
        'data-lang': 'en',
        crossorigin: 'anonymous',
        async: '',
      };

      let giscusScript = document.createElement('script');
      Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value));
      document.getElementById('giscus_thread').appendChild(giscusScript);
    </script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Matteo Lippi. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/mermaid@10.7.0/dist/mermaid.min.js" integrity="sha256-TtLOdUA8mstPoO6sGvHIGx2ceXrrX4KgIItO06XOn8A=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js" integrity="sha256-1rA678n2xEx7x4cTZ5x4wpUCj6kUMZEZ5cxLSVSFWxw=" crossorigin="anonymous"></script> <script defer src="/assets/js/mermaid-setup.js?38ca0a0126f7328d2d9a46bad640931f" type="text/javascript"></script> <script src="https://cdn.jsdelivr.net/npm/diff2html@3.4.47/bundles/js/diff2html-ui.min.js" integrity="sha256-eU2TVHX633T1o/bTQp6iIJByYJEtZThhF9bKz/DcbbY=" crossorigin="anonymous"></script> <script defer src="/assets/js/diff2html-setup.js?80a6e52ce727518bbd3aed2bb6ba5601" type="text/javascript"></script> <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.min.js" integrity="sha256-MgH13bFTTNqsnuEoqNPBLDaqxjGH+lCpqrukmXc8Ppg=" crossorigin="anonymous"></script> <script defer src="/assets/js/leaflet-setup.js?b6313931e203b924523e2d8b75fe8874" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js" integrity="sha256-0q+JdOlScWOHcunpUk21uab1jW7C1deBQARHtKMcaB4=" crossorigin="anonymous"></script> <script defer src="/assets/js/chartjs-setup.js?183c5859923724fb1cb3c67593848e71" type="text/javascript"></script> <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js" integrity="sha256-QvgynZibb2U53SsVu98NggJXYqwRL7tg3FeyfXvPOUY=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/theme/dark-fresh-cut.js" integrity="sha256-sm6Ui9w41++ZCWmIWDLC18a6ki72FQpWDiYTDxEPXwU=" crossorigin="anonymous"></script> <script defer src="/assets/js/echarts-setup.js?738178999630746a8d0cfc261fc47c2c" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/vega@5.27.0/build/vega.min.js" integrity="sha256-Yot/cfgMMMpFwkp/5azR20Tfkt24PFqQ6IQS+80HIZs=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/vega-lite@5.16.3/build/vega-lite.min.js" integrity="sha256-TvBvIS5jUN4BSy009usRjNzjI1qRrHPYv7xVLJyjUyw=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/vega-embed@6.24.0/build/vega-embed.min.js" integrity="sha256-FPCJ9JYCC9AZSpvC/t/wHBX7ybueZhIqOMjpWqfl3DU=" crossorigin="anonymous"></script> <script defer src="/assets/js/vega-setup.js?7c7bee055efe9312afc861b128fe5f36" type="text/javascript"></script> <script defer src="https://tikzjax.com/v1/tikzjax.js" integrity="sha256-+1qyucCXRZJrCg3lm3KxRt/7WXaYhBid4/1XJRHGB1E=" crossorigin="anonymous"></script> <script src="/assets/js/typograms.js?062e75bede72543443762dc3fe36c7a5"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?70d799092f862ad98c7876aa47712e20"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>